1.run() contains the job of the thread.
2.JVM calls run() atomatically when the start() is called

** OUTPUT order is not guaranteed in multithreading

3.Runnable is a functional interface : only run()
4.Multiple inheritance possible in Runnable

5.t1.start() : create new thread , calls run() internally : running Thread Name : Thread-0
6.t1.run() : no new thread ,running Thread Name : main

7. * Thread Object create : NEW
   * t1.start(): ready to run waiting for CPU from scedular OR actually executing : RUNNABLE
   * (Internally RUNNING is a part of RUNNABLE in java)
   * run() finish : TERMINATE

JAVA THREAD STATE : NEW , RUNNABLE , BLOCKED , WAITING , TIME_WAITING , TERMINATED

8. getState() return current thread state 
9. sleep(1000) : pause a thread for a fixed time : 1 second : Thread enter in TIME_WAITING state --> then return RUNNABLE
                --> InterruptedException 
                --> static method
                --> Does not release lock

main thread pause : waits until t1 completes : main thread enters WAITING state

join(); // wait indefinitely
join(long millis); // wait up to millis

THREAD Priority:
  --> Thread priority tells JVM which thread should get CPU first. BUt it is only a HINT, not a guarantee
  --> t1.setPriority(Thread.MIN_PRIORITY)
  ---> Thread.currentThread().getPriority()

  1- MIN_PRIORITY
  5- NORN_PRIORITY
  10- MAX_PRIORITY

  t1.setPriority(15) : throws --> IllegalArgumentException

  Deamon Thread : background thread runs only while user thread are running.
  --> when all user threads finish , JVM automatically stops daemon thread.
  eg : garbage collector